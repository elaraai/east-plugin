# East Plugin Hooks Design

## Problem Statement

When agents use East skills, they:
1. Read `SKILL.md` which provides high-level guidance
2. But `SKILL.md` can't contain all detailed API types and examples (too long)
3. Result: Agents make mistakes because they lack detailed API info

Additionally:
- Developers working on East projects don't know East skills are available
- No proactive engagement when Claude opens in an East project

## Goals

1. **Project Detection**: When Claude opens in a project with East dependencies, proactively inform about available skills
2. **Contextual Doc Injection**: When users ask about East topics, search and inject relevant docs from `reference/api.md` and `reference/examples.md`
3. **Skill-Scoped**: Only inject docs relevant to the specific East package being used

## Available Hook Events

| Hook | When it Fires | Can Inject Context? | Use Case |
|------|---------------|---------------------|----------|
| `SessionStart` | Claude opens/resumes | Yes (`additionalContext`) | Detect East project, announce skills |
| `UserPromptSubmit` | User sends message | Yes (`additionalContext`) | Search docs based on prompt |
| `PostToolUse` | After tool executes | Yes (`additionalContext`) | Inject docs after code is written |
| `PreToolUse` | Before tool executes | Limited (modify input) | Not useful for our case |

## Plugin Hooks vs Skill Hooks

Claude Code supports two types of hooks:

| Aspect | Plugin Hooks | Skill Hooks |
|--------|--------------|-------------|
| **Location** | `hooks/hooks.json` in plugin root | `SKILL.md` frontmatter (YAML) |
| **Supported Events** | All 10 types | Only `PreToolUse`, `PostToolUse`, `Stop` |
| **Scope** | Global while plugin enabled | Only during skill execution |
| **Lifecycle** | Persist while plugin is enabled | Auto-cleanup when skill ends |

**Why we use plugin hooks**: Our design requires `SessionStart` and `UserPromptSubmit` events, which are only available in plugin hooks. Skill hooks don't support these events.

**Potential skill hook addition**: We could add `PostToolUse` hooks to individual East skill `SKILL.md` files for code validation, scoped to when that skill is active. This is optional and separate from the plugin-level hooks.

## Proposed Architecture

```
east-plugin/
├── build/
│   └── index.json              # Pre-built search index (generated by CI, gitignored)
├── hooks/
│   ├── hooks.json              # Plugin hook configuration
│   ├── session-start.mjs       # Detect East project on startup
│   ├── prompt-submit.mjs       # Search docs based on user prompt
│   └── lib/
│       ├── search.mjs          # Search index management
│       └── routing.mjs         # Skill routing logic
├── skills/
│   ├── east/
│   │   ├── SKILL.md
│   │   └── reference/
│   │       ├── api.md
│   │       └── examples.md
│   ├── east-node-std/
│   │   └── ...
│   └── ...
├── scripts/
│   └── build-index.mjs         # Build search index (run by CI)
```

## Hook 1: SessionStart (Project Detection)

**Purpose**: When Claude opens, check if the project uses East and announce available skills.

**Trigger**: `SessionStart` with matcher `startup`

**Logic**:
```
1. Read $CLAUDE_PROJECT_DIR/package.json
2. Check dependencies for @elaraai/* packages
3. Map packages to skills:
   - @elaraai/east → east skill
   - @elaraai/east-node-std → east-node-std skill
   - @elaraai/east-node-io → east-node-io skill
   - @elaraai/east-py-datascience → east-py-datascience skill
   - @elaraai/east-ui → east-ui skill
   - @elaraai/e3 → e3 skill
4. Output additionalContext with:
   - Which East packages are installed
   - Which skills are available
   - Suggestion to use /east:<skill> for help
```

**Example Output**:
```
This project uses East packages:
- @elaraai/east (core language)
- @elaraai/east-node-std (Node.js platform functions)
- @elaraai/e3 (execution engine)

Available skills: /east:east, /east:east-node-std, /east:e3

Tip: Use these skills when writing East code for accurate API guidance.
```

## Hook 2: UserPromptSubmit (Doc Search)

**Purpose**: When user asks about East, search reference docs and inject relevant content.

**Trigger**: `UserPromptSubmit` (no matcher, fires on all prompts)

**Logic**:
```
1. Read prompt from stdin JSON
2. Check if prompt relates to East:
   - Contains "east" (case insensitive)
   - Contains East-specific terms: "East.function", "IntegerType", etc.
   - References @elaraai packages
3. If East-related:
   a. Extract keywords from prompt
   b. Determine which skills are relevant
   c. Search reference/api.md and reference/examples.md
   d. Extract matching sections with context
   e. Output additionalContext with relevant docs
4. If not East-related:
   - Exit 0 with no output (no injection)
```

**Keyword Extraction**:
```
Prompt: "How do I create an East function that sums an array?"

Keywords extracted:
- "East function" → search for "East.function"
- "array" → search for "ArrayType", "array"
- "sum" → search for ".sum()"

Skills to search:
- east (core language)
```

**Search Strategy**:
```python
def search_docs(skill_dir, keywords):
    results = []
    for doc in ['api.md', 'examples.md']:
        path = f"{skill_dir}/reference/{doc}"
        for keyword in keywords:
            matches = grep_with_context(path, keyword, before=2, after=10)
            results.extend(matches)
    return dedupe_and_truncate(results, max_chars=4000)
```

**Example Output**:
```
<east-reference>
## From api.md:

### East.function(inputTypes, outputType, body)
Creates a synchronous East function.
- inputTypes: Array of input types
- outputType: Return type
- body: Function body ($, ...inputs) => { ... }

## From examples.md:

// Sum an array of integers
const sumArray = East.function([ArrayType(IntegerType)], IntegerType, ($, arr) => {
    $.return(arr.sum());
});
</east-reference>
```

## Hook 3: PostToolUse (Code Validation) - Optional

**Purpose**: After code is written, check for common East mistakes and inject corrections.

**Trigger**: `PostToolUse` with matcher `Edit|Write`

**Logic**:
```
1. Check if edited file contains East imports
2. Scan for common mistakes:
   - Using East.IntegerType instead of IntegerType
   - Missing $.return() in function body
   - Wrong type for bigint (should use IntegerType)
3. If mistakes found, inject correction hints
```

**Note**: This is lower priority than SessionStart and UserPromptSubmit.

## Configuration: hooks/hooks.json

```json
{
  "description": "East plugin hooks for project detection and documentation injection",
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup|resume",
        "hooks": [
          {
            "type": "command",
            "command": "node ${CLAUDE_PLUGIN_ROOT}/hooks/session-start.mjs",
            "timeout": 10
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node ${CLAUDE_PLUGIN_ROOT}/hooks/prompt-submit.mjs",
            "timeout": 5
          }
        ]
      }
    ]
  }
}
```

## Environment Variables Available

| Variable | Available In | Description |
|----------|--------------|-------------|
| `CLAUDE_PROJECT_DIR` | All hooks | Project directory Claude is running in |
| `CLAUDE_PLUGIN_ROOT` | Plugin hooks | Root directory of the plugin |
| `CLAUDE_ENV_FILE` | SessionStart only | File to write env vars for session |

## Output Format

All hooks output JSON to inject context:

```json
{
  "hookSpecificOutput": {
    "hookEventName": "SessionStart|UserPromptSubmit|PostToolUse",
    "additionalContext": "Content to inject into Claude's context"
  }
}
```

Or plain text (for simpler cases):
```
This text is automatically added as context.
```

## Skill-to-Package Mapping

```json
{
  "@elaraai/east": "east",
  "@elaraai/east-node-std": "east-node-std",
  "@elaraai/east-node-io": "east-node-io",
  "@elaraai/east-py-datascience": "east-py-datascience",
  "@elaraai/east-ui": "east-ui",
  "@elaraai/e3": "e3",
  "@elaraai/e3-cli": "e3",
  "@elaraai/e3-core": "e3",
  "@elaraai/e3-types": "e3"
}
```

## Search Algorithm

The reference docs are well-structured markdown with `## Section` headers. We use MiniSearch for full-text search with field boosting.

### Document Structure

```markdown
# East API Reference          ← Title (ignored)

## East Namespace             ← Section header
Main entry point...           ← Section content
### Expression Creation       ← Subsection (included in parent)
| Signature | Description |
...

## BlockBuilder Operations    ← Next section
...
```

### Section Parsing

```typescript
interface Section {
  id: string;
  source: string;
  header: string;
  content: string;
  keywords: string[];
}

function parseSections(content: string, skillName: string, sourceFile: string): Section[] {
  const sections: Section[] = [];
  let current: { header: string; lines: string[] } | null = null;

  for (const line of content.split('\n')) {
    if (line.startsWith('## ')) {
      if (current) {
        const id = `${skillName}:${sourceFile.replace('.md', '')}:${current.header.toLowerCase().replace(/\s+/g, '-')}`;
        sections.push({
          id,
          source: sourceFile,
          header: current.header,
          content: current.lines.join('\n').slice(0, 2000),
          keywords: extractKeywords(current.header, current.lines.join('\n'))
        });
      }
      current = { header: line.slice(3).trim(), lines: [] };
    } else if (current) {
      current.lines.push(line);
    }
  }

  if (current) {
    const id = `${skillName}:${sourceFile.replace('.md', '')}:${current.header.toLowerCase().replace(/\s+/g, '-')}`;
    sections.push({
      id,
      source: sourceFile,
      header: current.header,
      content: current.lines.join('\n').slice(0, 2000),
      keywords: extractKeywords(current.header, current.lines.join('\n'))
    });
  }

  return sections;
}

function extractKeywords(header: string, content: string): string[] {
  const keywords = new Set<string>();

  // Header words
  header.toLowerCase().split(/\s+/).forEach(w => keywords.add(w));

  // East-specific patterns
  const patterns = [
    /East\.\w+/g,           // East.function, East.compile
    /\b[A-Z][a-z]+Type\b/g, // IntegerType, ArrayType
    /\$\.\w+/g,             // $.let, $.return
    /`([^`]+)`/g            // Inline code
  ];

  for (const pattern of patterns) {
    for (const match of content.matchAll(pattern)) {
      keywords.add(match[0].toLowerCase().replace(/`/g, ''));
    }
  }

  return [...keywords];
}
```

### MiniSearch Configuration

```typescript
import MiniSearch from 'minisearch';

function createIndex(sections: Section[]): MiniSearch {
  const index = new MiniSearch({
    fields: ['header', 'content', 'keywords'],
    storeFields: ['id', 'source', 'header', 'content'],
    searchOptions: {
      boost: { header: 3, keywords: 2, content: 1 },
      fuzzy: 0.2,
      prefix: true
    }
  });

  index.addAll(sections.map(s => ({
    ...s,
    keywords: s.keywords.join(' ')
  })));

  return index;
}

function search(index: MiniSearch, query: string, skills?: string[]): SearchResult[] {
  return index.search(query, {
    limit: 5,
    filter: skills ? (result) => skills.some(s => result.id.startsWith(s + ':')) : undefined
  });
}
```

### Format Output

```typescript
function formatResults(results: SearchResult[], maxChars = 2000): string {
  const output: string[] = [];
  let chars = 0;

  for (const result of results) {
    let text = result.content;
    if (text.length > 800) {
      text = text.slice(0, 800) + '\n... [truncated]';
    }

    const chunk = `### ${result.header}\n${text}`;
    if (chars + chunk.length > maxChars) break;

    output.push(chunk);
    chars += chunk.length;
  }

  return output.length > 0
    ? `## From ${results[0].source}:\n\n${output.join('\n\n')}`
    : '';
}
```

### Example Search

**User prompt**: "How do I iterate over an array and sum values in East?"

**Query terms extracted**:
- `('array', 0.5)`
- `('sum', 0.5)`
- `('iterate', 0.5)`

**Sections matched** (from api.md):
1. "Array Expressions" (score: 1.5) - header contains "array", keywords contain "sum"
2. "BlockBuilder Operations" (score: 0.5) - contains loop/iteration

**Sections matched** (from examples.md):
1. "Collections" (score: 1.0) - contains array examples with sum

**Output injected**:
```markdown
<east-reference>

## From api.md:

### Array Expressions
| Signature | Description |
| `arr.sum(): IntegerExpr \| FloatExpr` | Sum all elements |
| `arr.map(fn): ArrayExpr` | Transform each element |
| `arr.filter(fn): ArrayExpr` | Keep matching elements |
...

## From examples.md:

### Collections
```typescript
// Sum array of integers
const sumArray = East.function([ArrayType(IntegerType)], IntegerType, ($, arr) => {
    $.return(arr.sum());
});
```
...

</east-reference>
```

## Skill Routing

When a user asks a question, we need to determine which skill's docs to search.

### Strategy: Project Dependencies + Query Analysis

```typescript
const PACKAGE_TO_SKILL: Record<string, string> = {
  '@elaraai/east': 'east',
  '@elaraai/east-node-std': 'east-node-std',
  '@elaraai/east-node-io': 'east-node-io',
  '@elaraai/east-py-datascience': 'east-py-datascience',
  '@elaraai/east-ui': 'east-ui',
  '@elaraai/e3': 'e3',
  '@elaraai/e3-cli': 'e3',
  '@elaraai/e3-core': 'e3',
};

const SKILL_KEYWORDS: Record<string, string[]> = {
  'east': ['east.function', 'east.compile', 'type', 'expression', 'integertype', 'arraytype'],
  'east-node-std': ['console', 'filesystem', 'fetch', 'crypto', 'random', 'time', 'path'],
  'east-node-io': ['sql', 'sqlite', 'postgres', 'redis', 'mongodb', 's3', 'ftp', 'xlsx'],
  'east-py-datascience': ['optimize', 'mads', 'optuna', 'xgboost', 'lightgbm', 'torch', 'sklearn', 'shap'],
  'east-ui': ['component', 'button', 'input', 'table', 'chart', 'layout', 'form'],
  'e3': ['e3', 'task', 'pipeline', 'dataflow', 'workspace', 'package'],
};

function determineRelevantSkills(projectDeps: Set<string>, prompt: string): string[] {
  const relevant: string[] = [];
  const promptLower = prompt.toLowerCase();

  // 1. Start with skills matching project dependencies
  for (const [pkg, skill] of Object.entries(PACKAGE_TO_SKILL)) {
    if (projectDeps.has(pkg) && !relevant.includes(skill)) {
      relevant.push(skill);
    }
  }

  // 2. Boost/add skills based on prompt keywords
  for (const [skill, keywords] of Object.entries(SKILL_KEYWORDS)) {
    if (keywords.some(kw => promptLower.includes(kw))) {
      if (!relevant.includes(skill)) {
        relevant.push(skill);
      } else {
        // Move to front (higher priority)
        relevant.splice(relevant.indexOf(skill), 1);
        relevant.unshift(skill);
      }
    }
  }

  // 3. Always include 'east' if any East skill is relevant (it's the foundation)
  if (relevant.length > 0 && !relevant.includes('east')) {
    relevant.push('east');
  }

  return relevant.slice(0, 3); // Limit to top 3 skills
}
```

### Example Routing

| Prompt | Project Deps | Skills Searched |
|--------|--------------|-----------------|
| "How do I create an East function?" | `@elaraai/east` | `east` |
| "How do I read a file?" | `@elaraai/east`, `@elaraai/east-node-std` | `east-node-std`, `east` |
| "How do I query PostgreSQL?" | `@elaraai/east-node-io` | `east-node-io`, `east` |
| "How do I optimize with MADS?" | `@elaraai/east-py-datascience` | `east-py-datascience`, `east` |
| "How do I create a Button?" | `@elaraai/east-ui` | `east-ui`, `east` |
| "How do I run an e3 task?" | `@elaraai/e3` | `e3`, `east` |

## Pre-built Search Index

Instead of parsing docs at runtime, we pre-build a search index at CI time.

### Index Structure

```
east-plugin/
├── build/
│   └── index.json              # Pre-built search index (generated by CI, gitignored)
├── skills/
│   ├── east/
│   │   ├── SKILL.md
│   │   └── reference/
│   │       ├── api.md
│   │       └── examples.md
│   └── ...
└── scripts/
    └── build-index.mjs         # Index builder script
```

**Note**: The `build/` directory should be added to `.gitignore` since it contains generated artifacts that are rebuilt by CI.

### Index Format

```json
{
  "version": 1,
  "built": "2024-01-15T10:30:00Z",
  "skills": {
    "east": {
      "sections": [
        {
          "id": "east:api:east-namespace",
          "source": "api.md",
          "header": "East Namespace",
          "content": "Main entry point for building East programs...",
          "keywords": ["east.function", "east.compile", "east.value", "function", "compile"]
        },
        {
          "id": "east:api:blockbuilder",
          "source": "api.md",
          "header": "BlockBuilder Operations",
          "content": "The first argument ($) in function body...",
          "keywords": ["$.let", "$.const", "$.return", "$.if", "variable", "return"]
        }
      ]
    },
    "east-node-std": {
      "sections": [...]
    }
  }
}
```

### Search Library: MiniSearch from CDN

Use MiniSearch loaded from esm.sh (no bundling needed):

```javascript
// hooks/lib/search.mjs
let MiniSearch;

export async function initSearch() {
  if (!MiniSearch) {
    // Load from CDN - cached by Node.js
    const module = await import('https://esm.sh/minisearch@7');
    MiniSearch = module.default;
  }
  return MiniSearch;
}

export async function createSearchIndex(sections) {
  const MiniSearch = await initSearch();

  const index = new MiniSearch({
    fields: ['header', 'content', 'keywords'],
    storeFields: ['id', 'source', 'header', 'content'],
    searchOptions: {
      boost: { header: 3, keywords: 2, content: 1 },
      fuzzy: 0.2,
      prefix: true
    }
  });

  index.addAll(sections);
  return index;
}

export function search(index, query, options = {}) {
  const results = index.search(query, {
    limit: options.limit || 5,
    ...options
  });
  return results;
}
```

### Build Script: scripts/build-index.mjs

```javascript
#!/usr/bin/env node
// Run: node scripts/build-index.mjs

import { readFileSync, writeFileSync, readdirSync, existsSync } from 'fs';
import { join } from 'path';

const SKILLS_DIR = './skills';
const BUILD_DIR = './build';
const OUTPUT_FILE = `${BUILD_DIR}/index.json`;

function parseSections(content, skillName, sourceFile) {
  const sections = [];
  let current = null;

  for (const line of content.split('\n')) {
    if (line.startsWith('## ')) {
      if (current) sections.push(current);
      const header = line.slice(3).trim();
      const id = `${skillName}:${sourceFile.replace('.md', '')}:${header.toLowerCase().replace(/\s+/g, '-')}`;
      current = { id, source: sourceFile, header, lines: [], keywords: new Set() };
    } else if (current) {
      current.lines.push(line);
    }
  }
  if (current) sections.push(current);

  // Extract keywords and finalize
  return sections.map(s => {
    const content = s.lines.join('\n');
    const keywords = extractKeywords(s.header, content);
    return {
      id: s.id,
      source: s.source,
      header: s.header,
      content: content.slice(0, 2000), // Truncate long sections
      keywords: [...keywords]
    };
  });
}

function extractKeywords(header, content) {
  const keywords = new Set();

  // Header words
  header.toLowerCase().split(/\s+/).forEach(w => keywords.add(w));

  // East patterns
  const patterns = [
    /East\.\w+/g,
    /\b[A-Z][a-z]+Type\b/g,
    /\$\.\w+/g,
    /`([^`]+)`/g
  ];

  for (const pattern of patterns) {
    for (const match of content.matchAll(pattern)) {
      keywords.add(match[0].toLowerCase().replace(/`/g, ''));
    }
  }

  return keywords;
}

function buildIndex() {
  const index = {
    version: 1,
    built: new Date().toISOString(),
    skills: {}
  };

  const skillDirs = readdirSync(SKILLS_DIR, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name);

  for (const skill of skillDirs) {
    const refDir = join(SKILLS_DIR, skill, 'reference');
    if (!existsSync(refDir)) continue;

    index.skills[skill] = { sections: [] };

    for (const file of ['api.md', 'examples.md']) {
      const filePath = join(refDir, file);
      if (!existsSync(filePath)) continue;

      const content = readFileSync(filePath, 'utf-8');
      const sections = parseSections(content, skill, file);
      index.skills[skill].sections.push(...sections);
    }

    console.log(`Indexed ${skill}: ${index.skills[skill].sections.length} sections`);
  }

  writeFileSync(OUTPUT_FILE, JSON.stringify(index, null, 2));
  console.log(`\nWrote ${OUTPUT_FILE}`);
}

buildIndex();
```

### GitHub Action Integration

Add to `.github/workflows/update-skills.yml`:

```yaml
      - name: Copy skills
        run: |
          # ... existing copy logic ...

      - name: Build search index
        run: |
          node scripts/build-index.mjs

      - name: Clean up source repos
        run: rm -rf .sources
```

### Runtime Search (hooks/lib/search.mjs)

```javascript
import { readFileSync } from 'fs';
import { join } from 'path';

let searchIndex = null;
let MiniSearch = null;

export async function loadIndex(pluginRoot) {
  if (searchIndex) return searchIndex;

  // Load MiniSearch from CDN
  if (!MiniSearch) {
    const module = await import('https://esm.sh/minisearch@7');
    MiniSearch = module.default;
  }

  // Load pre-built index
  const indexPath = join(pluginRoot, 'skills', 'index.json');
  const data = JSON.parse(readFileSync(indexPath, 'utf-8'));

  // Build MiniSearch index from pre-built data
  searchIndex = new MiniSearch({
    fields: ['header', 'content', 'keywords'],
    storeFields: ['id', 'source', 'header', 'content'],
    searchOptions: {
      boost: { header: 3, keywords: 2, content: 1 },
      fuzzy: 0.2,
      prefix: true
    }
  });

  // Add all sections from relevant skills
  for (const [skill, skillData] of Object.entries(data.skills)) {
    for (const section of skillData.sections) {
      searchIndex.add({
        ...section,
        keywords: section.keywords.join(' '),
        skill
      });
    }
  }

  return searchIndex;
}

export function search(query, options = {}) {
  if (!searchIndex) throw new Error('Index not loaded');

  return searchIndex.search(query, {
    limit: options.limit || 5,
    filter: options.skills
      ? (result) => options.skills.includes(result.skill)
      : undefined
  });
}
```

## Refined Hook Flow

### SessionStart Hook

```
1. Check package.json for East dependencies
2. If East deps found:
   a. Load pre-built index.json
   b. Initialize MiniSearch with relevant skill sections
   c. Output welcome message listing available skills
3. Exit 0
```

### UserPromptSubmit Hook

```
1. Quick check: does prompt contain East-related keywords?
   - If no: exit 0 immediately (no injection, <10ms)
2. Read package.json to get project East dependencies
3. Load search index (from SessionStart or re-init)
4. Search index with prompt, filtered by relevant skills
5. Format top 3-5 results (max 4000 chars)
6. Output JSON with additionalContext
7. Exit 0
```

### Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                     BUILD TIME (CI)                              │
├─────────────────────────────────────────────────────────────────┤
│  reference/*.md  ──►  build-index.mjs  ──►  build/index.json   │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     RUNTIME (User's machine)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  SessionStart:                                                   │
│    package.json ──► detect deps ──► load index.json             │
│                                          │                       │
│                                          ▼                       │
│                                    MiniSearch (in memory)        │
│                                          │                       │
│  UserPromptSubmit:                       │                       │
│    prompt ──► keyword check ──► search ──┘                      │
│                                    │                             │
│                                    ▼                             │
│                              matched sections                    │
│                                    │                             │
│                                    ▼                             │
│                           additionalContext ──► Claude           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Performance Considerations

1. **SessionStart**: Only runs once per session (or on resume), can take up to 10s
2. **UserPromptSubmit**: Runs on every prompt, must be <500ms for good UX
   - Skip early if not an East project (check cached deps)
   - Use pre-built search index (no parsing at runtime)
   - Limit search results to top 3-5
   - Exit immediately with code 0 and no output if no matches
3. **Truncation**: Keep injected context under 4000 chars to avoid overwhelming Claude
4. **Caching**: Cache project dependencies from SessionStart to avoid re-reading package.json

## Testing Strategy

1. **SessionStart**:
   ```bash
   # Create test project with East deps
   mkdir /tmp/test-east && cd /tmp/test-east
   echo '{"dependencies":{"@elaraai/east":"*"}}' > package.json

   # Run hook manually
   CLAUDE_PROJECT_DIR=/tmp/test-east CLAUDE_PLUGIN_ROOT=/path/to/east-plugin \
     node /path/to/east-plugin/hooks/session-start.mjs
   ```

2. **UserPromptSubmit**:
   ```bash
   # Simulate prompt input
   echo '{"prompt":"How do I create an East function?"}' | \
     CLAUDE_PROJECT_DIR=/tmp/test-east CLAUDE_PLUGIN_ROOT=/path/to/east-plugin \
     node /path/to/east-plugin/hooks/prompt-submit.mjs
   ```

## Design Decisions

1. **Hook Language: Node.js (ES Modules)**
   - East users already have Node.js 22+ installed
   - Native JSON handling, good regex support
   - Can share patterns with East TypeScript code
   - MiniSearch library available via CDN

2. **Multiple Matching Skills: Prioritized List**
   - Search up to 3 most relevant skills based on project deps + prompt keywords
   - Boost skills that match prompt keywords to the front
   - Always include `east` skill as foundation if any East skill matches

3. **PostToolUse: Deferred**
   - Start with SessionStart + UserPromptSubmit hooks
   - Consider adding PostToolUse later for code validation if needed
   - Could be implemented as skill-specific hooks in SKILL.md frontmatter

## Edge Cases and Mitigations

| Edge Case | Mitigation |
|-----------|------------|
| No package.json | Skip project detection, still allow skill keyword matching |
| Very long prompt | Truncate to first 500 chars for keyword extraction |
| No matching sections | Return empty, don't inject noise |
| Multiple skills match equally | Prefer skill with most specific keyword match |
| Docs are huge | Pre-truncate sections to 800 chars during parsing |
| User asks non-East question | Quick keyword check exits early (<10ms) |
| Hook times out | Set 5s timeout, fail gracefully with no injection |
| Cache corrupted | Delete and rebuild on next SessionStart |

## Final File Structure

```
east-plugin/
├── hooks/
│   ├── hooks.json                    # Hook configuration
│   ├── session-start.mjs             # Project detection + cache init
│   ├── prompt-submit.mjs             # Doc search + injection
│   └── lib/
│       ├── search.mjs                # Section parsing and search
│       ├── routing.mjs               # Skill routing logic
│       └── cache.mjs                 # Cache management
├── skills/
│   ├── east/
│   │   ├── SKILL.md
│   │   └── reference/
│   │       ├── api.md
│   │       └── examples.md
│   ├── east-node-std/
│   │   ├── SKILL.md
│   │   └── reference/
│   │       ├── api.md
│   │       └── examples.md
│   └── ... (other skills)
├── docs/
│   └── hooks-design.md               # This document
└── README.md
```

## hooks/hooks.json

```json
{
  "description": "East plugin hooks for project detection and documentation injection",
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup|resume",
        "hooks": [
          {
            "type": "command",
            "command": "node ${CLAUDE_PLUGIN_ROOT}/hooks/session-start.mjs",
            "timeout": 10
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node ${CLAUDE_PLUGIN_ROOT}/hooks/prompt-submit.mjs",
            "timeout": 5
          }
        ]
      }
    ]
  }
}
```

## Implementation Order

1. **Phase 1**: SessionStart hook (project detection + welcome message)
2. **Phase 2**: Search library (section parsing, scoring, formatting)
3. **Phase 3**: UserPromptSubmit hook (doc search + injection)
4. **Phase 4**: Caching (performance optimization)
5. **Phase 5**: PostToolUse hook (code validation) - optional
